parameters:
  - name: environment
    displayName: Environment
    type: string
    default: Dev
    values:
    - Dev
    - Test
    - Prod
  - name: failover_deployment
    displayName: 'Failover Deployment'
    type: boolean
    default: false

variables:
- group: Terraform ${{ parameters.environment }}
- name: armServiceConnectionName
  value: ${{ replace(format('ODW {0}', parameters.environment), 'Test', 'PreProd') }}
- name: artifactName
  value: terraform-plan
- name: environment
  value: ${{ lower(parameters.environment) }}
- name: failoverDeployment
  value: ${{ lower(parameters.failover_deployment) }}
- name: outputFileName
  value: outputs.json
- name: planFileName
  value: tfplan
- name: postDeploymentDelaySeconds
  value: 180
- name: tfOutputDataLakeAccountId
  value: data_lake_account_id
- name: tfOutputDataLakeAccountIdFailover
  value: data_lake_account_id_failover

pr: none

trigger: none

pool:
  vmImage: ubuntu-22.04

stages:
  - stage: Plan
    displayName: Terraform Plan ${{ parameters.environment }}
    jobs:
    - job: Plan
      displayName: Terraform Plan
      steps:
      # Checkout repo
      - checkout: self
        displayName: 'Checkout'

      # Login to Azure using Terraform service principal
      - template: steps/azure-login.yaml
        parameters:
          servicePrincipalId: $(AZURE_SERVICE_PRINCIPAL_ID)
          servicePrincipalSecret: $(AZURE_SERVICE_PRINCIPAL_SECRET)
          subscriptionId: $(SUBSCRIPTION_ID)
          tenantId: $(AZURE_TENANT_ID)

      # Initialise and run terraform plan
      - script: |
          echo "Initialising Terraform using state file ${{ variables.environment }}.tfstate..."
          echo "##[command]terraform init -backend-config="key=${{ variables.environment }}.tfstate" -input=false"
          terraform init \
            -backend-config="key=${{ variables.environment }}.tfstate" \
            -input=false

          echo "Planning Terraform deployment..."
          echo "##[command]terraform plan -var-file=./environments/${{ variables.environment }}.tfvars -input=false -out=${{ variables.planFileName }}"
          terraform plan \
            -var-file=./environments/${{ variables.environment }}.tfvars \
            -var "failover_deployment=${{ variables.failoverDeployment }}" \
            -input=false \
            -out=${{ variables.planFileName }}
        displayName: 'Terraform Plan'
        workingDirectory: infrastructure
        env:
          ARM_CLIENT_ID: $(AZURE_SERVICE_PRINCIPAL_ID)
          ARM_CLIENT_SECRET: $(AZURE_SERVICE_PRINCIPAL_SECRET)
          ARM_SUBSCRIPTION_ID: $(SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(AZURE_TENANT_ID)

      # Copy Terraform plan files to artifact directory
      - task: CopyFiles@2
        displayName: 'Create Artifact'
        inputs:
          sourceFolder: infrastructure
          contents: |
            .terraform/**
            .terraform.lock.hcl
            *.tftpl
            ${{ variables.planFileName }}
          targetFolder: $(Build.ArtifactStagingDirectory)

      # Publish pipeline artifacts
      - publish: $(Build.ArtifactStagingDirectory)
        artifact: ${{ variables.artifactName }}
        displayName: 'Publish Artifact'

  - stage: Apply
    dependsOn: Plan
    displayName: Terraform Apply ${{ parameters.environment }}
    jobs:
    - deployment: Apply
      displayName: Terraform Apply
      environment: ${{ parameters.environment }}
      strategy:
        runOnce:
          deploy:
            steps:
            # Checkout repo
            - checkout: self
              displayName: 'Checkout'

            # Download pipeline artifacts
            - download: current
              artifact: ${{ variables.artifactName }}
              displayName: 'Download Artifact'

            # Verify terraform plan file
            - script: |
                echo "Searching for ${{ variables.planFileName }} in $(Pipeline.Workspace)/${{ variables.artifactName }}..."
                echo "##[command][[ ! -d "$(Pipeline.Workspace)/${{ variables.artifactName }}" ]]"

                if [[ ! -d "$(Pipeline.Workspace)/${{ variables.artifactName }}" ]]; then
                  echo "##[warning]Failed to find Terraform Plan, skipping Terraform Apply"
                  echo "##vso[task.setvariable variable=skipApply]true"
                else
                  echo "Found ${{ variables.planFileName }} file..."
                  ehco "##[command]chmod -R +x $(Pipeline.Workspace)/${{ variables.artifactName }}"
                  chmod -R +x $(Pipeline.Workspace)/${{ variables.artifactName }}
                fi

                echo "##[command]ls -l $(Pipeline.Workspace)/${{ variables.artifactName }}"
                ls -l $(Pipeline.Workspace)/${{ variables.artifactName }}
              displayName: 'Verify Artifact'

            # Login to Azure using Terraform service principal
            - template: steps/azure-login.yaml
              parameters:
                servicePrincipalId: $(AZURE_SERVICE_PRINCIPAL_ID)
                servicePrincipalSecret: $(AZURE_SERVICE_PRINCIPAL_SECRET)
                subscriptionId: $(SUBSCRIPTION_ID)
                tenantId: $(AZURE_TENANT_ID)

            # Unlock resources
            - task: AzurePowerShell@5
              displayName: 'Unlock Resources'
              inputs:
                ConnectedServiceNameARM: ${{ variables.armServiceConnectionName }}
                errorActionPreference: 'stop'
                inline: |
                  Write-Host "Checking resource locks..."
                  Write-Host "##[command]Get-AzResourceLock -Scope /subscriptions/$(SUBSCRIPTION_ID)"
                  $ResourceLocks = Get-AzResourceLock -Scope "/subscriptions/$(SUBSCRIPTION_ID)"
                  $ResourceLocks | ConvertTo-Json

                  Foreach ($Lock in $ResourceLocks) {
                    Write-Host "Removing resource lock for $($Lock.ResourceType)/$($Lock.ResourceName)..."
                    Write-Host "##[command]Remove-AzResourceLock -LockId $($Lock.LockId)"
                    $Removed = Remove-AzResourceLock -LockId $($Lock.LockId) -Force

                    [PsCustomObject]@{
                      LockId      = $($Lock.LockId)
                      LockRemoved = $Removed
                    } | ConvertTo-Json
                  }
                scriptType: inlineScript
                TargetAzurePs: LatestVersion

            # Run terraform apply using the plan file artifact
            - script: |
                echo "Initialising Terraform using state file ${{ variables.environment }}.tfstate..."
                echo "##[command]terraform init -backend-config="key=${{ variables.environment }}.tfstate" -input=false"
                terraform init \
                  -backend-config="key=${{ variables.environment }}.tfstate" \
                  -input=false

                echo "Deploying Terraform..."
                echo "##[command]terraform apply -input=false $(Pipeline.Workspace)/${{ variables.artifactName }}/${{ variables.planFileName }}"
                terraform apply \
                  -input=false $(Pipeline.Workspace)/${{ variables.artifactName }}/${{ variables.planFileName }}
              condition: ne(variables['skipApply'], 'true')
              displayName: 'Terraform Apply'
              workingDirectory: infrastructure
              env:
                ARM_CLIENT_ID: $(AZURE_SERVICE_PRINCIPAL_ID)
                ARM_CLIENT_SECRET: $(AZURE_SERVICE_PRINCIPAL_SECRET)
                ARM_SUBSCRIPTION_ID: $(SUBSCRIPTION_ID)
                ARM_TENANT_ID: $(AZURE_TENANT_ID)

            # Pause pipeline after Terraform deployment
            - script: |
                echo "Pausing pipeline for ${{ variables.postDeploymentDelaySeconds }} seconds..."
                echo "##[command]sleep ${{ variables.postDeploymentDelaySeconds }}"
                sleep ${{ variables.postDeploymentDelaySeconds }}
              displayName: 'Post-Deployment Pause'

            # Retrieve the data lake Storage Account ID
            - script: |
                echo "Retrieving data lake account ID from state file..."
                echo "##[command]terraform output -raw ${{ variables.tfOutputDataLakeAccountId }}"
                DATA_LAKE_PRIMARY_ID=$(terraform output -raw ${{ variables.tfOutputDataLakeAccountId }})
                echo $DATA_LAKE_PRIMARY_ID

                echo "##[command]terraform output -raw ${{ variables.tfOutputDataLakeAccountIdFailover }}"
                DATA_LAKE_SECONDARY_ID=$(terraform output -raw ${{ variables.tfOutputDataLakeAccountIdFailover }})
                echo $DATA_LAKE_SECONDARY_ID

                echo "Setting pipeline variables..."
                echo "##[command][task.setvariable variable=data_lake_account_id;isoutput=false]$DATA_LAKE_PRIMARY_ID"
                echo "##vso[task.setvariable variable=data_lake_account_id;isoutput=false]$DATA_LAKE_PRIMARY_ID"

                echo "##[command][task.setvariable variable=data_lake_account_id_failover;isoutput=false]$DATA_LAKE_SECONDARY_ID"
                echo "##vso[task.setvariable variable=data_lake_account_id_failover;isoutput=false]$DATA_LAKE_SECONDARY_ID"
              displayName: 'Terraform Output'
              workingDirectory: infrastructure
              env:
                ARM_CLIENT_ID: $(AZURE_SERVICE_PRINCIPAL_ID)
                ARM_CLIENT_SECRET: $(AZURE_SERVICE_PRINCIPAL_SECRET)
                ARM_SUBSCRIPTION_ID: $(SUBSCRIPTION_ID)
                ARM_TENANT_ID: $(AZURE_TENANT_ID)

            # Approve the data lake managed private endpoint if it has been reinstated
            - task: AzurePowerShell@5
              displayName: 'Approve Endpoint'
              inputs:
                ConnectedServiceNameARM: ${{ variables.armServiceConnectionName }}
                errorActionPreference: 'stop'
                inline: |
                  $DataLakeIds = @(
                    "$(data_lake_account_id)",
                    "$(data_lake_account_id_failover)"
                  )

                  Foreach ($Id in $DataLakeIds) {
                    $ResourceName = $Id.Split("/")[-1]
                    $EndTime = (Get-Date).AddSeconds(120)
                    Write-Host "Checking private endpoint connections for $ResourceName..."
                    Write-Host "##[command]Get-AzPrivateEndpointConnection -PrivateLinkResourceId $Id"

                    $i = 0
                    Do {
                      $Endpoints = Get-AzPrivateEndpointConnection -PrivateLinkResourceId $Id
                      Start-Sleep -Seconds 10
                      $i += 10
                      Write-Host "... [$i`s]"
                    } Until (($null -ne $Endpoints) -or ((Get-Date) -gt $EndTime))

                    If ($null -eq $Endpoints) {
                      Throw "Failed to find private endpoint connections for $ResourceName"
                    }

                    Foreach ($Endpoint in $Endpoints) {
                      [PsCustomObject]@{
                        Name                  = $Endpoint.Name
                        Id                    = $Endpoint.Id
                        ProvisioningState     = $Endpoint.ProvisioningState
                        ConnectionState       = $Endpoint.PrivateLinkServiceConnectionState.Status
                        ConnectionDescription = $Endpoint.PrivateLinkServiceConnectionState.Description
                      } | ConvertTo-Json

                      If ($Endpoint.PrivateLinkServiceConnectionState.Status -ne "Approved") {
                        $ApprovalDescription = "Approved by $(Build.DefinitionName) pipeline"
                        Write-Host "Approving private endpoint connection $($Endpoint.Name)..."
                        Write-Host "##[command]Approve-AzPrivateEndpointConnection -ResourceId $Endpoint.Id -Description $ApprovalDescription"
                        $Approval = Approve-AzPrivateEndpointConnection -ResourceId $Endpoint.Id -Description $ApprovalDescription

                        [PsCustomObject]@{
                          Name                  = $Approval.Name
                          Id                    = $Approval.Id
                          ProvisioningState     = $Approval.ProvisioningState
                          ConnectionState       = $Approval.PrivateLinkServiceConnectionState.Status
                          ConnectionDescription = $Approval.PrivateLinkServiceConnectionState.Description
                        } | ConvertTo-Json
                      }
                    }
                  }
                scriptType: inlineScript
                TargetAzurePs: LatestVersion

            # Lock resources
            - task: AzurePowerShell@5
              displayName: 'Lock Resources'
              inputs:
                ConnectedServiceNameARM: ${{ variables.armServiceConnectionName }}
                errorActionPreference: 'stop'
                inline: |
                  $DataLakeIds = @(
                    "$(data_lake_account_id)",
                    "$(data_lake_account_id_failover)"
                  )

                  Foreach ($Id in $DataLakeIds) {
                    $LockConfig = @{
                      LockName  = "Prevent Deletion"
                      LockLevel = "CanNotDelete"
                      LockNotes = "Locked by $(Build.DefinitionName) pipeline"
                      Scope     = $Id
                    }

                    Write-Host "Applying resource lock for $Id..."
                    Write-Host "##[command]Set-AzResourceLock @LockConfig"
                    $ResourceLock = Set-AzResourceLock @LockConfig -Force
                    $ResourceLock | ConvertTo-Json
                  }
                scriptType: inlineScript
                TargetAzurePs: LatestVersion
